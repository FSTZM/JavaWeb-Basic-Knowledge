一.多对多关系
	表:
		使用中间表,分别引用两方的ID
	对象: 
		两方都使用集合表达
	配置:
		<set name="courses" table="t_student_course"  >
			<key column="sid" ></key>
			<many-to-many class="Course" column="cid" ></many-to-many>
		</set>
	
	操作:
		inverse: 我是否要放弃维护外键关系
		cascade: 是否需要级联操作 (5个)
	注意: 配置级联删除时,要小心,双方都配置级联删除, 任意删除一条记录, 整个关系链数据都会被删除.
二.加载策略(优化查询)
	策略种类:
		延迟加载: 等到使用的时候才会加载数据.
		立即加载: 不管使用不使用,都会立刻将数据加载.
	策略的应用:
		类级别的加载策略.
		关联级别的加载策略.
//----------------------------------------------------------------------
	类级别加载策略:
			1. get/load
				get: 立即查询数据库,将数据初始化
				load:  hbm文件中,class元素的lazy属性绝对类级别load方法的加载策略
						true:先返回一个代理对象.使用代理对象的属性时,才去查询数据库.
						false: 与get一致,会立即加载数据
//----------------------------------------------------------------------	
	关联级别加载策略
			在查询有关联关系的数据时,加载一方的数据是否需要将另一方立即查询出.
			默认: 与我关联的数据,在使用时才会加载.
		集合(一对多):
			set 
				lazy: 是否对set数据使用懒加载
					true:(默认值) 对集合使用才加载
					false: 集合将会被立即加载
					extra: 极其懒惰,如果使用集合时,之调用size方法查询数量, Hibernate会发送count语句,只查询数量.不加载集合内数据.
				fetch : 决定加载集合使用的sql语句种类
					select: (默认值) 普通select查询
					join: 表链接语句查询集合数据
					subselect: 使用子查询 一次加载多个Customer的订单数据
		fetch		lazy	结论
	 ------------------------------
		select  	true	默认值, 会在使用集合时加载,普通select语句
		select		false	立刻使用select语句加载集合数据
		select		extra	会在使用集合时加载,普通select语句,如果只是获得集合的长度,会发送Count语句查询长度.
		join		true	查询集合时使用表链接查询,会立刻加载集合数据
		join		false	查询集合时使用表链接查询,会立刻加载集合数据
		join		extra	查询集合时使用表链接查询,会立刻加载集合数据
		subselect	true	会在使用集合时加载,子查询语句
		subselect	false	会在查询用户时,立即使用子查询加载客户的订单数据
		subselect   extra	会在使用集合时加载,子查询语句,如果只是获得集合的长度,会发送Count语句查询长度.
------------------------------------------------------------------------------------------	
	多对一:
		lazy
 			false		加载订单时,会立即加载客户
 			proxy		看客户对象的类加载策略来决定
 			no-proxy : 不做研究. 
 		fetch=
			select  : (默认值)使用普通select加载
			join	: 使用表链接加载数据
	
	fetch			lazy			结果
---------------------------------------------------
	select			false			加载订单时,立即加载客户数据.普通select语句加载客户.
	select			proxy			类加载策略为:lazy=false 同上
												 lazy=true	加载订单时,先不加载客户数据.使用客户数据时才加载
	join			false			使用表链接查询订单以及对应客户信息.lazy属性无效
	join			proxy			使用表链接查询订单以及对应客户信息.lazy属性无效
-------------------------------------------------------------------------------------------
批量加载
	set
		batch-size: 决定一次加载几个对象的集合数据. in 条件加载多个用户的订单.
	
三.查询总结
	Hibernate查询分类:
			1. get/load  根据OID检索
			2. 对象视图检索  c.getOrders
			3. Sql语句  createSqlQuery
			4. Hql语句 createQuery
			5. Criteria查询 createCriteria 
	HQL 详解
	QBC 详解
四.事务.连接池.锁 相关设置



数据库中的锁

数据库的锁(了解的了解)
		悲观锁(数据库提供实现) . 默认认为一定会发送别人要修改我使用的数据. 那我就可以为我读取的数据加锁.
			读锁/共享锁  =>  读锁可被其他线程所共享,如果是读取的话大家都可以用这把锁读到数据.
				select * from table lock in share mode（读锁、共享锁）
				
			写锁/排他锁	 =>  写锁不能共享,只要有人为数据加入了写锁,其他人就不能为数据加任何锁.
				select * from table for update （写锁、排它锁）
				
		乐观锁(需要自己实现)

	